
#include "share.h"
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <signal.h>

#define Stou_0 "\033[0m"	// RESET
#define Stou_R "\033[0;31m" // RED
#define Stou_G "\033[0;32m" // GREEN
#define Stou_Y "\033[0;33m" // YELLOW

// Fix des warns sur Windows
#ifndef SIGRTMIN
#define SIGRTMIN 0
#endif
#ifndef SIG_BLOCK
#define SIG_BLOCK 0
#endif
#ifndef SA_SIGINFO
#define SA_SIGINFO 0
#endif

int8_t clients = 0;
pid_t client_pid;

/**
 * Handler for the signal.
 * @param signum the received signal number
 * @param info the signal information
 * @param context the context of the signal
 */
void handler(int signum, siginfo_t *info, void *context) {
	client_pid = info->si_pid;
	// Client connected
	if (info->si_value.sival_int == 0) {
		printf(Stou_G "Client connecté (PID: %d)\n" Stou_0, info->si_pid);
		clients++;
	}
	// Client disconnected
	else if (info->si_value.sival_int == 1) {
		printf(Stou_Y "Client déconnecté (PID: %d)\n" Stou_0, info->si_pid);
		clients--;
		return;
	}

	// Client request
	if (signum == SIGRTMIN) {
		;
	}
}

int main(int argc, char *argv[]) {
	printf("\n");

	// Check arguments
	if (argc < 3) {
		printf(Stou_R "Usage: " Stou_Y "%s" Stou_R " <nom_du_tube> <val1> [val2] [val3] [val4] ...\n" Stou_0, argv[0]);
		exit(EXIT_FAILURE);
	}

	// Create shared variable
	shared_var_t shared_var = initSharedVar(argc - 2);
	int_fast32_t i;
	for (i = 0; i < shared_var.req.tab_size; i++) {
		shared_var.req.tab[i] = atoi(argv[i + 2]);
	}

	// Create pipe
	shared_var.req.fd = open(argv[1], O_WRONLY);
	if (shared_var.req.fd == -1) {
		perror(Stou_R "Erreur lors de l'ouverture du tube nommé" Stou_0);
		exit(EXIT_FAILURE);
	}

	// Waiting for client
	printf(Stou_Y "Serveur en attente de la demande du client...\n" Stou_0);

	siginfo_t info;
	sigset_t set;
	struct sigaction action;
	action.sa_flags = SA_SIGINFO;
	action.sa_sigaction = handler;

	sigfillset(&action.sa_mask);
	sigdelset(&action.sa_mask, SIGRTMIN);
	sigdelset(&action.sa_mask, SIGINT);

	if (sigprocmask(SIG_BLOCK, &action.sa_mask, NULL) == -1) {
        perror(Stou_R "Erreur lors du blocage des signaux\n" Stou_0);
        exit(EXIT_FAILURE);
    }
	if (sigaction(0, &action, NULL) == -1) {
		perror(Stou_R "Erreur lors de l'installation du handler\n" Stou_0);
		exit(EXIT_FAILURE);
	}
	pause();

	// Client connected
	printf(Stou_Y "Client connecté (PID: %d)\n" Stou_0, client_pid);

	while (clients > 0) {
		pause();
	}







	printf("\n");
	return EXIT_SUCCESS;
}

