
#include <stdio.h>
#include <stdlib.h>
#include <ncurses.h>
#include <locale.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <errno.h>

#include "functions.h"
#include "window.h"
#include "colors.h"
#include "include.h"

/**
 * Returns a random integer in intervalle [a, b].
 * @param a the lower bound
 * @param b the upper bound
 * @return a random integer
 */
int random_integer(int a, int b) {
    return rand() % (b - a + 1) + a;
}

/**
 * Main function.
 * @param argc the number of arguments
 * @param argv arguments
 * @return the return code
 */
int main(int argc, char *argv[]) {
    bool stop = FALSE, played;
    window_t *win_player, *win_computer, *win_infos;
    int n, rest, index;
    int posX, posY, x, y;
    unsigned char *player_grid, *computer_grid;
    int *player_rest, *computer_rest;
	char* computer_msg;
	struct sembuf op;
 
    // Initialize the pseudo-random number generator
    srand(time(NULL) + getpid());

	// Create semaphore set
	int semid = semget(KEY + 1, 2, IPC_CREAT | S_IRUSR | S_IWUSR);
	if (semid == -1) {
		perror("Error while creating semaphore set");
		exit(EXIT_FAILURE);
	}

	// Initialize semaphore set
	if (semctl(semid, 0, SETVAL, 1) == -1) {
		perror("Error while initializing semaphore set");
		exit(EXIT_FAILURE);
	}
 
    // #TODO# #1 create a shared memory segment that contains:
    // - the player and computer grids
    // - the boats counters
    // - the computer message to display
	size_t size = 0
		+ sizeof(unsigned char) * WIDTH * HEIGHT * 2
		+ sizeof(int) * 2
		+ sizeof(char) * 16;
	int shmid = shmget(KEY, size, IPC_CREAT | S_IRUSR | S_IWUSR);
    
    // #TODO# #2 map the segment
    // - player_grid the player's grid
    // - computer_grid the computer's grid
    // - player_rest the number of player remaining boats
    // - computer_rest the number of computer remaining boats
    // - computer_msg the computer's message
	player_grid = shmat(shmid, NULL, 0);
	computer_grid = player_grid + sizeof(unsigned char) * WIDTH * HEIGHT;
	player_rest = (int*)(computer_grid + sizeof(unsigned char) * WIDTH * HEIGHT);
	computer_rest = player_rest + 1;
	computer_msg = (char*)(computer_rest + 1);
	if (player_grid == (void*)-1) {
		perror("Error while attaching shared memory segment");
		exit(EXIT_FAILURE);
	}
    
    // Initialize the grids, the boats counters, and the computer message
    memset(player_grid, ' ', sizeof(unsigned char) * WIDTH * HEIGHT);
    memset(computer_grid, ' ', sizeof(unsigned char) * WIDTH * HEIGHT);
    *player_rest = BOATS;
    *computer_rest = BOATS;
	computer_msg[0] = '\0';
        
    // ncurses initialization
    ncurses_init();
    ncurses_init_mouse();
    ncurses_colors(); 
    palette();
    clear();
    refresh();
    
    // Check the terminal dimensions
    if((COLS < WIDTH * 2 + 2) || (LINES < HEIGHT + 9)) {
        ncurses_stop();
        fprintf(stderr, 
              "Dimensions are invalid (%d,%d). width must be greater than %d and height mut be greater than %d\n",
              COLS, LINES, WIDTH * 2 + 2, HEIGHT + 9);
        exit(EXIT_FAILURE);
    }
    
    // Create windows
    win_infos = window_create(0, 0, COLS, 7, "Informations", TRUE);
    win_player = window_create(0, 7, WIDTH + 2, HEIGHT + 2, "Player", FALSE);    
    win_computer = window_create(WIDTH + 2, 7, WIDTH + 2, HEIGHT + 2, "Computer", FALSE);    
    
    // Loop to place boats
    window_printw(win_infos, "Press 'S' to stop the game.");
    window_printw(win_infos, "\nPlace your %d boats by clicking in your grid.", BOATS);
    window_refresh(win_infos);
    rest = BOATS;
    while((stop == FALSE) && (rest > 0) && (n = getch())) {
        switch(n) {
            case 's':
            case 'S':
                stop = TRUE;
                break;
            case KEY_MOUSE:
                if(mouse_getpos(&posX, &posY) == OK) {
                    if(window_getcoordinates(win_player, posX, posY, &x, &y) == TRUE) {
                        if(player_grid[y * WIDTH + x] != 'X') {
                            player_grid[y * WIDTH + x] = 'X';
                            window_mvaddch_col(win_player, y, x, YELLOW, 'X');
                            window_refresh(win_player);
                            window_printw(win_infos, "\nYou place a boat at (%d,%d).", x, y);
                            rest--;
                        }
                        else
                            window_printw(win_infos, "\nThere's already a boat here...");
                        window_refresh(win_infos);
                    }
                }
                break;
        }
    }
    
    // Place computer boats
    if(stop == FALSE) {
        window_printw(win_infos, "\nWaiting for computer.");
        window_refresh(win_infos);
        
        // #TODO# #6 how to wait for the computer to start and place its boats?
		// P(S1, 1)
		op.sem_num = 0;
		op.sem_op = -1;
		op.sem_flg = 0;
		if (semop(semid, &op, 1) == -1) {
			perror("Error on semaphore operation (1)");
			exit(EXIT_FAILURE);
		}
        
        window_printw(win_infos, "\nComputer is connected and has placed its boats.");
        window_refresh(win_infos);
    }    
    
    // Main loop
    while((stop == FALSE) && (*player_rest > 0) && (*computer_rest > 0)) {
        // Player's turn
        window_printw(win_infos, "\nClick in the computer grid to shot.");
        window_refresh(win_infos);
        played = FALSE;
        while((stop == FALSE) && (played == FALSE)) {
            n = getch();
            switch(n) {
                case 's':
                case 'S':
                    stop = TRUE;
                    break;
                case KEY_MOUSE:
                    if(mouse_getpos(&posX, &posY) == OK) {
                        if(window_getcoordinates(win_computer, posX, posY, &x, &y) == TRUE) {
                            index = y * WIDTH + x;
                            if((computer_grid[index] != ' ') && (computer_grid[index] != 'X'))
                                window_printw(win_infos, "\nYou already shoot here.");
                            else {
                                played = TRUE;
                                if(computer_grid[index] == 'X') {
                                    window_printw_col(win_infos, RED, "\nYou destroyed a boat.");
                                    window_mvaddch_col(win_computer, y, x, RED, 'X');
                                    window_refresh(win_computer);
                                    computer_grid[index] = 'T';
                                    *computer_rest -= 1;
                                }
                                else {
                                    window_printw(win_infos, "\nYou shot in water and you killed a dolphin.");
                                    window_mvaddch_col(win_computer, y, x, BLUE, 'M');
                                    window_refresh(win_computer);
                                    computer_grid[index] = 'M';
                                }
                            }
                            window_refresh(win_infos);
                        }
                    }
                    break;
            }
        }
        
        // Computer's turn
        if((stop == FALSE) && (*player_rest > 0) && (*computer_rest > 0)) {
			// #TODO# #7 how to wait for the computer to play?
			// V(S2, 1)
			op.sem_num = 1;
			op.sem_op = 1;
			op.sem_flg = 0;
			if (semop(semid, &op, 1) == -1) {
				perror("Error on semaphore operation (2)");
				exit(EXIT_FAILURE);
			}
			// P(S1, 1)
			op.sem_num = 0;
			op.sem_op = -1;
			op.sem_flg = 0;
			if (semop(semid, &op, 1) == -1) {
				perror("Error on semaphore operation (1)");
				exit(EXIT_FAILURE);
			}
        
            // #TODO# #10
            // - Display the computer message in the shared memory segment
			printf("Computer message: %s\n", computer_msg);
            // - Update the player grid (to display the computer shot)
			int x, y;
			sscanf(computer_msg, "%d %d", &x, &y);
			index = y * WIDTH + x;
			if(player_grid[index] == 'X') {
				window_printw_col(win_infos, RED, "\nComputer destroyed one of your boats.");
				window_mvaddch_col(win_player, y, x, RED, 'X');
				player_grid[index] = 'T';
				*player_rest -= 1;
			}
			else {
				window_printw(win_infos, "\nComputer shot in water and killed a dolphin.");
				window_mvaddch_col(win_player, y, x, BLUE, 'M');
				player_grid[index] = 'M';
			}
			window_refresh(win_player);
        }
    }
    
    // End of the game or stop demanded
    if(stop == FALSE) {
        if(*player_rest == 0)
            window_printw_col(win_infos, RED, "\nYou lose!");
        else
            window_printw_col(win_infos, GREEN, "\nYou won!");
    }
    else
        window_printw(win_infos, "\nYou stoped the game.");
    window_refresh(win_infos);
    sleep(2);
    
    // Stop ncurses
    window_delete(&win_player);
    window_delete(&win_computer);
    window_delete(&win_infos);
    ncurses_stop();

	// Delete semaphore set
	if (semctl(semid, 0, IPC_RMID) == -1) {
		perror("Error while deleting the semaphore set");
		exit(EXIT_FAILURE);
	}
    
    // Delete the shared memory segment
    if (shmctl(shmid, IPC_RMID, NULL) == -1) {
		perror("Error while deleting the shared memory segment");
		exit(EXIT_FAILURE);
	}

    return EXIT_SUCCESS;    
}

