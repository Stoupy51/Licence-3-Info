
#include "include.h"

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#define GRID_LINES 20
#define GRID_COLUMNS 20
#define GRID_SIZE 400

int8_t loop = 1;
char* grid;

/**
 * @brief Handler for SIGINT signal.
 * @param signum the received signal number
 */
void handler(int signum) {
	printf(YELLOW"[Server #main] Stop request received.\n"RESET);
	loop = 0;
}

/**
 * @brief Child function.
 * @param id child ID
 * @param clientfd client socket file descriptor
*/
void child(int id, int clientfd) {

	// Print connected IP
	printf("[Server-child #%d] Child connected to entry ", id);
	{
		struct sockaddr_in client_address;
		socklen_t client_address_len = sizeof(struct sockaddr_in);
		getpeername(clientfd, (struct sockaddr*)&client_address, &client_address_len);
		char ip[INET_ADDRSTRLEN];
		inet_ntop(AF_INET, &client_address.sin_addr, ip, INET_ADDRSTRLEN);
		// Remaining print
		printf("%s:%d.\n", ip, ntohs(client_address.sin_port));
	}

	// Placing randomly the client id in the grid at the first free place
	int i;
	do {
		i = rand() % (GRID_SIZE);
	} while(grid[i] != '0');
	grid[i] += id;

	// Send the grid to the client (firsly the size and then the grid)
	size_t size = GRID_LINES;
	if (sendto(clientfd, &size, sizeof(size_t), 0, NULL, 0) == -1) {
		fprintf(stderr, RED"[Server-child #%d] Error sending grid size.\n"RESET, id);
		exit(EXIT_FAILURE);
	}
	if (sendto(clientfd, grid, GRID_SIZE, 0, NULL, 0) == -1) {
		fprintf(stderr, RED"[Server-child #%d] Error sending grid.\n"RESET, id);
		exit(EXIT_FAILURE);
	}

	// Sleep 5 seconds
	sleep(5);

	// Close socket
	printf("[Server-child #%d] Child stopping.\n", id);
	if (close(clientfd) == -1) {
		fprintf(stderr, RED"[Server-child #%d] Error closing socket\n"RESET, id);
		exit(EXIT_FAILURE);
	}

	// Exit
	exit(EXIT_SUCCESS);
}

/**
 * Main function.
 * 
 * @brief Create TCP server waiting for connections.
 * For each connection, create a child process that will wait 5 seconds and then close the connection.
 * 
 * @param argc number of arguments
 * @param argv arguments
 * 
 * @return int EXIT_SUCCESS or EXIT_FAILURE
*/
int main(int argc, char** argv) {

	// Port initialization
	int port = 0;
	if (argc == 2)
		port = atoi(argv[1]);
	else {
		printf(YELLOW"No port specified, using automatic port.\n"RESET);
	}

	// Register SIGINT handler
	struct sigaction action;
	sigemptyset(&action.sa_mask);
	action.sa_flags = 0;
	action.sa_handler = handler;
	if (sigaction(SIGINT, &action, NULL) == -1) {
		perror(RED"Error positioning handler\n"RESET);
		exit(EXIT_FAILURE);	
	}

	// Create TCP socket
	int sockfd;
	if((sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
		perror(RED"Error creating socket\n"RESET);
		exit(EXIT_FAILURE);
	}

	// Fill server address
	struct sockaddr_in server_address;
	memset(&server_address, 0, sizeof(struct sockaddr_in));
	server_address.sin_family = AF_INET;			// IPv4
	server_address.sin_port = htons(port);			// Port (automatic if 0)
	server_address.sin_addr.s_addr = INADDR_ANY;	// Any address (first choosen by OS)

	// Name socket (bind address to socket) (turn server_address pointer to sockaddr*)
	if (bind(sockfd, (struct sockaddr*)&server_address, sizeof(struct sockaddr_in)) == -1) {
		perror(RED"Error naming socket\n"RESET);
		exit(EXIT_FAILURE);
	}

	// Switch the socket in passive mode
	if (listen(sockfd, 1) == -1) {
		perror(RED"Error switching socket in passive mode\n"RESET);
		exit(EXIT_FAILURE);
	}

	// Message showing server properties (IP:port)
	{
		char ip[INET_ADDRSTRLEN];
		inet_ntop(AF_INET, &server_address.sin_addr, ip, INET_ADDRSTRLEN);
		struct sockaddr_in sin;
		socklen_t len = sizeof(sin);
		int port = 0;
		if (getsockname(sockfd, (struct sockaddr *)&sin, &len) == -1)
			perror(RED"Error getting socket name\n"RESET);
		else
			port = ntohs(sin.sin_port);
		printf(GREEN"Server started, listening on %s:%d.\n"RESET, ip, port);
	}

	// Create 20x20 grid in shared memory segment
	size_t size = GRID_SIZE * sizeof(char);
	int shmid = shmget(KEY, size, IPC_CREAT | S_IRUSR | S_IWUSR);
	if (shmid == -1) {
		perror(RED"Error creating shared memory segment\n"RESET);
		exit(EXIT_FAILURE);
	}
	grid = shmat(shmid, NULL, 0);
	memset(grid, '0', size);

	// Loop until stop
	loop = 1;
	int childId = 0;
	printf(GREEN"[Server #main] Waiting for connections...\n"RESET);
	while (loop) {

		// Variables initialization
		struct sockaddr_in client_address;
		socklen_t client_address_len = sizeof(struct sockaddr_in);
		int clientfd;

		// Accept connection
		if ((clientfd = accept(sockfd, (struct sockaddr*)&client_address, &client_address_len)) == -1) {
			perror(RED"Error accepting connection\n"RESET);
			exit(EXIT_FAILURE);
		}

		// Create child
		childId++;
		if (fork() == 0) {
			if (close(sockfd) == -1) {
				perror(RED"Error closing socket while creating child.\n"RESET);
				exit(EXIT_FAILURE);
			}
			child(childId, clientfd);
		}
		else {
			if (close(clientfd) == -1) {
				perror(RED"Error closing client socket while creating child.\n"RESET);
				exit(EXIT_FAILURE);
			}
		}
	}

	// Close socket
	if (close(sockfd) == -1) {
		perror(RED"Error closing socket.\n"RESET);
		exit(EXIT_FAILURE);
	}

	// Print message and exit
	printf(GREEN"[Server #main] done.\n"RESET);
	return EXIT_SUCCESS;
}

