#include <stdlib.h>

#include "window.h"
#include "functions.h"
#include "image.h"
#include "colors.h"

#include "interface.h"

/**
 * Check terminal dimensions.
 */
void interface_dimensions() {
	if ((COLS < T_WIDTH) || (LINES < T_HEIGHT)) {
		ncurses_stop();
		fprintf(stderr, "Terminal size is too small: actually w=%d,h=%d instead of l=%d,h=%d\n", COLS, LINES, T_WIDTH, T_HEIGHT);
		exit(EXIT_FAILURE);
	} 
}

/**
 * Create interface.
 * @param[in] level the level
 * @return created interface
 */
interface_t *interface_create(image_t *level) {
	interface_t *result;
	int i;
	
	// Check terminal dimensions
	interface_dimensions();
	
	// Structure allocation
	if ((result = malloc(sizeof(interface_t))) == NULL) {
		ncurses_stop();
		perror("Error allocating structure");
		exit(EXIT_FAILURE);
	}
	result->level = level;

	// Create level window
	result->win_level = window_create(0, 0, L_WIDTH, L_HEIGHT, "Level", false);
	for (i = 0; i < level->height * level->width; i++) {
		window_addch_col(result->win_level, level->image[i], ' ');
	}
	window_refresh(result->win_level);
	
	// Create tools window
	result->win_tools = window_create(L_WIDTH, 0, TOOLS_WIDTH, L_HEIGHT, "Tools", false);
	result->selection = FD_WHITE;
	interface_tools_update(result);

	// Create information window
	result->win_infos = window_create(0, 22, T_WIDTH, 5, "Informations", true);
	window_printw_col(result->win_infos, RED, "Press 'Q' to quit...");
	window_printw(result->win_infos, "\nClick on a color and click on the level... that's all!");
	window_refresh(result->win_infos);

	return result;
}

/**
 * Delete interface.
 * @param[in,out] interface the interface to delete
 */
void interface_delete(interface_t **interface) {
	window_delete(&(*interface)->win_infos);
	window_delete(&(*interface)->win_tools);
	window_delete(&(*interface)->win_level);
	image_delete(&(*interface)->level);
	free(*interface);
	interface = NULL;
}

/**
 * Update tools window
 * @param[in,out] interface the interface
 */
void interface_tools_update(interface_t *interface) {
	window_erase(interface->win_tools);

	interface_tools_update_util(interface, TT_DELETE, " Delete\n");
	interface_tools_update_util(interface, TT_BLOCK	, " Block\n");
	interface_tools_update_util(interface, TT_LADDER, " Ladder\n");
	interface_tools_update_util(interface, TT_TRAP	, " Trap\n");
	interface_tools_update_util(interface, TT_GATE	, " Gate\n");
	interface_tools_update_util(interface, TT_KEY	, " Key\n");
	interface_tools_update_util(interface, TT_DOOR	, " Door\n");
	interface_tools_update_util(interface, TT_EXIT	, " Exit\n");
	interface_tools_update_util(interface, TT_START	, " Start\n");
	interface_tools_update_util(interface, TT_ROBOT	, " Robot\n");
	interface_tools_update_util(interface, TT_PROBE	, " Probe\n");
	interface_tools_update_util(interface, TT_LIFE	, " Life\n");
	interface_tools_update_util(interface, TT_BOMB	, " Bomb\n");

	window_refresh(interface->win_tools);
}

/**
 * Manage actions in the tools window.
 * @param[in,out] interface the interface
 * @param[in] posX X position of the click in the window
 * @param[in] posY Y position of the click in the window
 */
void interface_tools_actions(interface_t *interface, int posX, int posY) {
	if ((posY >= 0) && (posY < TT_SIZE)) {
		interface->selection = posY + 1;
		interface_tools_update(interface);
	}
	else if (posY == KEY_UP || posY == KEY_DOWN) {
		if (posY == KEY_UP)
			interface->selection = (interface->selection + TT_SIZE - 2) % TT_SIZE + 1;
		else
			interface->selection = (interface->selection) % TT_SIZE + 1;
		interface_tools_update(interface);
	}
}

/**
 * Manage actions in the level window.
 * @param[in,out] interface l'interface
 * @param[in] posX X position of the click in the window
 * @param[in] posY Y position of the click in the window
 */
void interface_image_actions(interface_t *interface, int posX, int posY) {
	#define img interface->level->image

	// Basic tools
	if (TT_SINGLE_BLOCK(interface->selection)) {
		img[posY * interface->level->width + posX] = interface->selection;
		switch(interface->selection) {
		case TT_DELETE:
			window_mvaddch_col(interface->win_level, posY, posX, COLOR_BLACK, ' ');
			break;
		case TT_BLOCK:
			window_mvaddch_col(interface->win_level, posY, posX, FD_CYAN	, ' ');
			break;
		case TT_TRAP:
			window_mvaddch_col(interface->win_level, posY, posX, FD_CYAN	, 'X');
			break;
		case TT_LIFE:
			window_mvaddch_col(interface->win_level, posY, posX, RED		, 'V');
			break;
		case TT_BOMB:
			window_mvaddch_col(interface->win_level, posY, posX, WHITE		, 'o');
			break;
		default:
			break;
		}
		window_refresh(interface->win_level);
		return;
	}

	// Specials tools
	int pos;
	switch (interface->selection) {

	case TT_LADDER: // Size : 3x1
		if (posX + 2 < interface->level->width) {
			pos = posY * interface->level->width + posX;
			img[pos] 		= TT_LADDER;
			img[pos + 1] 	= TT_DELETE;
			img[pos + 2] 	= TT_DELETE;
			window_mvaddch_col(interface->win_level, posY, posX		, YELLOW, ACS_LTEE);
			window_mvaddch_col(interface->win_level, posY, posX + 1	, YELLOW, ACS_HLINE);
			window_mvaddch_col(interface->win_level, posY, posX + 2	, YELLOW, ACS_RTEE);
		}
		break;

	case TT_GATE: // Size : 1x4
		if (posY + 3 < interface->level->height) {
			img[posY * interface->level->width + posX] 			= TT_GATE;
			img[(posY + 1) * interface->level->width + posX] 	= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX] 	= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX] 	= TT_DELETE;
			window_mvaddch_col(interface->win_level, posY, posX		, MAGENTA, ACS_PLUS);
			window_mvaddch_col(interface->win_level, posY + 1, posX	, MAGENTA, ACS_PLUS);
			window_mvaddch_col(interface->win_level, posY + 2, posX	, MAGENTA, ACS_PLUS);
			window_mvaddch_col(interface->win_level, posY + 3, posX	, MAGENTA, ACS_PLUS);
		}
		break;

	case TT_KEY: // Size : 1x2
		if (posY + 1 < interface->level->width) {
			img[posY * interface->level->width + posX] 			= TT_KEY;
			img[(posY + 1) * interface->level->width + posX] 	= TT_DELETE;
			window_mvaddch_col(interface->win_level, posY, posX		, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY, posX + 1	, MAGENTA	, ACS_LLCORNER);
		}
		break;
	
	case TT_DOOR: // Size : 3x4
		if (posX + 2 < interface->level->width && posY + 3 < interface->level->height) {
			pos = posY * interface->level->width + posX;
			img[pos] 												= TT_DOOR;
			img[pos + 1] 											= TT_DELETE;
			img[pos + 2] 											= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX + 2] 	= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX + 2] 	= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX + 2] 	= TT_DELETE;
			window_mvaddch_col(interface->win_level, posY, posX			, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY, posX + 1		, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY, posX + 2		, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY + 1, posX		, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY + 1, posX + 1	, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY + 1, posX + 2	, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY + 2, posX		, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY + 2, posX + 1	, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY + 2, posX + 2	, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY + 3, posX		, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY + 3, posX + 1	, FD_GREEN, ' ');
			window_mvaddch_col(interface->win_level, posY + 3, posX + 2	, FD_GREEN, ' ');
		}
		break;
	
	case TT_EXIT: // Size : 3x4
		if (posX + 2 < interface->level->width && posY + 3 < interface->level->height) {
			pos = posY * interface->level->width + posX;
			img[pos] 												= TT_EXIT;
			img[pos + 1] 											= TT_DELETE;
			img[pos + 2] 											= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX + 2] 	= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX + 2] 	= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX + 2] 	= TT_DELETE;
			window_mvaddch_col(interface->win_level, posY, posX			, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY, posX + 1		, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY, posX + 2		, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY + 1, posX		, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY + 1, posX + 1	, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY + 1, posX + 2	, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY + 2, posX		, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY + 2, posX + 1	, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY + 2, posX + 2	, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY + 3, posX		, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY + 3, posX + 1	, FD_YELLOW, ' ');
			window_mvaddch_col(interface->win_level, posY + 3, posX + 2	, FD_YELLOW, ' ');
		}
		break;
	
	case TT_START: // Size : 3x4
		if (posX + 2 < interface->level->width && posY + 3 < interface->level->height) {
			pos = posY * interface->level->width + posX;
			img[pos] 												= TT_START;
			img[pos + 1] 											= TT_DELETE;
			img[pos + 2] 											= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX + 2] 	= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX + 2] 	= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX + 2] 	= TT_DELETE;
			window_mvaddch_col(interface->win_level, posY, posX			, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY, posX + 1		, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY, posX + 2		, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY + 1, posX		, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY + 1, posX + 1	, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY + 1, posX + 2	, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY + 2, posX		, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY + 2, posX + 1	, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY + 2, posX + 2	, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY + 3, posX		, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY + 3, posX + 1	, FD_MAGENTA, ' ');
			window_mvaddch_col(interface->win_level, posY + 3, posX + 2	, FD_MAGENTA, ' ');
		}
		break;
	
	case TT_ROBOT: // Size : 3x4
		if (posX + 2 < interface->level->width && posY + 3 < interface->level->height) {
			pos = posY * interface->level->width + posX;
			img[pos] 												= TT_ROBOT;
			img[pos + 1] 											= TT_DELETE;
			img[pos + 2] 											= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX + 2] 	= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 2) * interface->level->width + posX + 2] 	= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 3) * interface->level->width + posX + 2] 	= TT_DELETE;
			window_mvaddch_col(interface->win_level, posY, posX			, WHITE, ACS_ULCORNER);
			window_mvaddch_col(interface->win_level, posY, posX + 1		, WHITE, ACS_BTEE);
			window_mvaddch_col(interface->win_level, posY, posX + 2		, WHITE, ACS_URCORNER);
			window_mvaddch_col(interface->win_level, posY + 1, posX		, WHITE, ACS_LLCORNER);
			window_mvaddch_col(interface->win_level, posY + 1, posX + 1	, WHITE, ACS_TTEE);
			window_mvaddch_col(interface->win_level, posY + 1, posX + 2	, WHITE, ACS_LRCORNER);
			window_mvaddch_col(interface->win_level, posY + 2, posX		, WHITE, ACS_HLINE);
			window_mvaddch_col(interface->win_level, posY + 2, posX + 1	, WHITE, ACS_PLUS);
			window_mvaddch_col(interface->win_level, posY + 2, posX + 2	, WHITE, ACS_HLINE);
			window_mvaddch_col(interface->win_level, posY + 3, posX		, WHITE, ACS_ULCORNER);
			window_mvaddch_col(interface->win_level, posY + 3, posX + 1	, WHITE, ACS_BTEE);
			window_mvaddch_col(interface->win_level, posY + 3, posX + 2	, WHITE, ACS_URCORNER);
		}
		break;
	
	case TT_PROBE: // Size : 3x2
		if (posX + 2 < interface->level->width && posY + 1 < interface->level->height) {
			pos = posY * interface->level->width + posX;
			img[pos] 												= TT_PROBE;
			img[pos + 1] 											= TT_DELETE;
			img[pos + 2] 											= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX] 		= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX + 1] 	= TT_DELETE;
			img[(posY + 1) * interface->level->width + posX + 2] 	= TT_DELETE;
			window_mvaddch_col(interface->win_level, posY, posX			, WHITE, ACS_LTEE);
			window_mvaddch_col(interface->win_level, posY, posX + 1		, WHITE, ACS_HLINE);
			window_mvaddch_col(interface->win_level, posY, posX + 2		, WHITE, ACS_RTEE);
			window_mvaddch_col(interface->win_level, posY + 1, posX		, WHITE, ACS_LLCORNER);
			window_mvaddch_col(interface->win_level, posY + 1, posX + 1	, WHITE, ACS_HLINE);
			window_mvaddch_col(interface->win_level, posY + 1, posX + 2	, WHITE, ACS_LRCORNER);
		}
		break;
	
	default:
		break;
	}
	window_refresh(interface->win_level);
}

/**
 * Manage actions of the user.
 * @param[in,out] interface the interface
 * @param[in] c the pressed key
 */
void interface_actions(interface_t *interface, int c) {
	int mouseX, mouseY, posX, posY;

	// Mouse management
	if ((c == KEY_MOUSE) && (mouse_getpos(&mouseX, &mouseY) == OK)) {
#ifdef _DEBUG_
		window_printw(interface->win_infos, "\nClick (%d,%d)", mouseX, mouseY);
		window_refresh(interface->win_infos);
#endif
		
		if (window_getcoordinates(interface->win_tools, mouseX, mouseY, &posX, &posY)) {
			interface_tools_actions(interface, posX, posY);
		}
		else if (window_getcoordinates(interface->win_level, mouseX, mouseY, &posX, &posY)) {
			interface_image_actions(interface, posX, posY);
		}
	}
	else {
		/* Key management: to modify for the project */
		if ((c >= '0') && (c <= '9'))
			interface_tools_actions(interface, 0, c - '0');
		else if (c == KEY_UP || c == KEY_DOWN)
			interface_tools_actions(interface, 0, c);
		else
			switch(c) {
				default:
#ifdef _DEBUG_				
					window_printw(interface->win_infos, "\nKey %d pressed", c);
					window_refresh(interface->win_infos);
#endif
					break;
			}
	}
}