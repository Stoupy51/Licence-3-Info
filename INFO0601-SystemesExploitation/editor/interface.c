#include <stdlib.h>

#include "window.h"
#include "functions.h"
#include "image.h"
#include "colors.h"

#include "interface.h"

/**
 * Check terminal dimensions.
 */
void interface_dimensions() {
	if((COLS < T_WIDTH) || (LINES < T_HEIGHT)) {
		ncurses_stop();
		fprintf(stderr, "Terminal size is too small: actually w=%d,h=%d instead of l=%d,h=%d\n", COLS, LINES, T_WIDTH, T_HEIGHT);
		exit(EXIT_FAILURE);
	} 
}

/**
 * Create interface.
 * @param[in] level the level
 * @return created interface
 */
interface_t *interface_create(image_t *level) {
	interface_t *result;
	int i;
	
	// Check terminal dimensions
	interface_dimensions();
	
	// Structure allocation
	if((result = malloc(sizeof(interface_t))) == NULL) {
		ncurses_stop();
		perror("Error allocating structure");
		exit(EXIT_FAILURE);
	}
	result->level = level;

	// Create level window
	result->win_level = window_create(0, 0, L_WIDTH, L_HEIGHT, "Level", false);
	for(i = 0; i < level->height * level->width; i++) {
		window_addch_col(result->win_level, level->image[i], ' ');
	}
	window_refresh(result->win_level);
	
	// Create tools window
	result->win_tools = window_create(L_WIDTH, 0, TOOLS_WIDTH, L_HEIGHT, "Tools", false);
	result->selection = FD_WHITE;
	interface_tools_update(result);

	// Create information window
	result->win_infos = window_create(0, 22, T_WIDTH, 5, "Informations", true);
	window_printw_col(result->win_infos, RED, "Press 'Q' to quit");
	window_printw(result->win_infos, "\nClick on a color and click on the level... that's all!");
	window_refresh(result->win_infos);

	return result;
}

/**
 * Delete interface.
 * @param[in,out] interface the interface to delete
 */
void interface_delete(interface_t **interface) {
	window_delete(&(*interface)->win_infos);
	window_delete(&(*interface)->win_tools);
	window_delete(&(*interface)->win_level);
	image_delete(&(*interface)->level);
	free(*interface);
	interface = NULL;
}

#define interface_tools_update_util(interface, tool, tool_string) \
	if (interface->selection == tool) { \
		window_color(interface->win_tools, WHITE); \
		window_printw(interface->win_tools, ">"); \
	} \
	else { \
		window_color(interface->win_tools, RED); \
		window_printw(interface->win_tools, " "); \
	} \
	window_printw(interface->win_tools, tool_string);

/**
 * Update tools window
 * @param[in,out] interface the interface
 */
void interface_tools_update(interface_t *interface) {
	window_erase(interface->win_tools);

	interface_tools_update_util(interface, TT_DELETE, " Delete\n");
	interface_tools_update_util(interface, TT_BLOCK	, " Block\n");
	interface_tools_update_util(interface, TT_LADDER, " Ladder\n");
	interface_tools_update_util(interface, TT_TRAP	, " Trap\n");
	interface_tools_update_util(interface, TT_GATE	, " Gate\n");
	interface_tools_update_util(interface, TT_KEY	, " Key\n");
	interface_tools_update_util(interface, TT_DOOR	, " Door\n");
	interface_tools_update_util(interface, TT_EXIT	, " Exit\n");
	interface_tools_update_util(interface, TT_START	, " Start\n");
	interface_tools_update_util(interface, TT_ROBOT	, " Robot\n");
	interface_tools_update_util(interface, TT_PROBE	, " Probe\n");
	interface_tools_update_util(interface, TT_LIFE	, " Life\n");
	interface_tools_update_util(interface, TT_BOMB	, " Bomb\n");

	window_refresh(interface->win_tools);
}

/**
 * Manage actions in the tools window.
 * @param[in,out] interface the interface
 * @param[in] posX X position of the click in the window
 * @param[in] posY Y position of the click in the window
 */
void interface_tools_actions(interface_t *interface, int posX, int posY) {
	if((posY >= 0) && (posY <= 7)) {
		switch(posY) {
			case 0:
				interface->selection = WHITE;
				break;
			case 1:
				interface->selection = FD_WHITE;
				break;
			case 2:
				interface->selection = FD_GREEN;
				break;
			case 3:
				interface->selection = FD_BLUE;
				break;
			case 4:
				interface->selection = FD_RED;
				break;
			case 5:
				interface->selection = FD_YELLOW;
				break;
			case 6:
				interface->selection = FD_CYAN;
				break;
			case 7:
				interface->selection = FD_MAGENTA;
				break;
		}
		interface_tools_update(interface);
	}
}

/**
 * Manage actions in the level window.
 * @param[in,out] interface l'interface
 * @param[in] posX X position of the click in the window
 * @param[in] posY Y position of the click in the window
 */
void interface_image_actions(interface_t *interface, int posX, int posY) {
	interface->level->image[posY * interface->level->width + posX] = interface->selection;
	window_mvaddch_col(interface->win_level, posY, posX, interface->selection, ' ');
	window_refresh(interface->win_level);
}

/**
 * Manage actions of the user.
 * @param[in,out] interface the interface
 * @param[in] c the pressed key
 */
void interface_actions(interface_t *interface, int c) {
	int mouseX, mouseY, posX, posY;

	// Mouse management
	if((c == KEY_MOUSE) && (mouse_getpos(&mouseX, &mouseY) == OK)) {
#ifdef _DEBUG_
		window_printw(interface->win_infos, "\nClick (%d,%d)", mouseX, mouseY);
		window_refresh(interface->win_infos);
#endif
		
		if(window_getcoordinates(interface->win_tools, mouseX, mouseY, &posX, &posY)) {
			interface_tools_actions(interface, posX, posY);
		}
		else if(window_getcoordinates(interface->win_level, mouseX, mouseY, &posX, &posY)) {
			interface_image_actions(interface, posX, posY);
		}
	}
	else {
		/* Key management: to modify for the project */
		if((c >= '0') && (c <= '8'))
			interface_tools_actions(interface, 0, c - '0');
		else
			switch(c) {
				default:
#ifdef _DEBUG_				
					window_printw(interface->win_infos, "\nKey %d pressed", c);
					window_refresh(interface->win_infos);
#endif
					break;
			}
	}
}