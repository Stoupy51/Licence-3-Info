
// Ensembles disjoints
composantes-connexes(G)
	Pour chaque sommet V appartenant à G.sommets
		créer-ensemble(V)
	Pour chaque arete (u,v) appartenant à G.aretes
		Si trouver-ensemble(u) != trouver-ensemble(v)
			union(u,v) // unie les ensembles de u et v

meme-composante(u,v)
	return trouver-ensemble(u) == trouver-ensemble(v)

crée-ensemble(x)
	créer une nouvelle liste chainée dont l'objet unique est x

trouver-ensemble(x)
	return x.ensemble.tete

union(x,y)
	x.ensemble.queue.succ = y.ensemble.tete
	x.ensemble.queue = y.ensemble.queue
	pour chaque objet z faisant partie de l'ensemble de y
		z.ensemble = x.ensemble


### Tas ###
parent(i)
	return i / 2

gauche(i)
	return 2 * i

droite(i)
	return 2 * i + 1

entasser-max(t,i)
	g = gauche(i)
	d = droite(i)
	si g <= t.taille && t[g] > t[i]
		max = g
	sinon
		max = i
	si d <= t.taille && t[d] > t[max]
		max = d
	si max != i
		echanger t[i] et t[max]
		entasser-max(t,max)










#Part 2 : Table d'adressage direct

rechercher-adressage-direct(t,k):
	return t[k]

insérer-adressage-direct(t, x):
	t[x.clé] = x

supprimer-adressage-direct(t, x):
	t[x.clé] = NIL


insérer-hachage-chainée(t, x):
	insérer x en tête de la liste t[h(x.cle)]

rechercher-hachage-chainée(t, k):
	rechercher un élément de clé k dans la liste t[h(k)]

supprimer-hachage-chainée(t, x):
	supprimer x de la liste t[h(x.cle)]


afficher-arbre-recursif(x):
	si x != NIL
		afficher x.clé
		afficher-arbre-recursif(x.gauche)
		afficher-arbre-recursif(x.droite)

afficher-arbre-iteratif(x):
	si x != NIL
		p = pile vide
		empiler(p, x)
		tant que p n'est pas vide:
			y = depiler(p)
			afficher x.clé
			si x.droite != NIL
				empiler(p, x.droite)
			si x.gauche != NIL
				empiler(p, x.gauche)


